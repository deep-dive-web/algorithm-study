# 해시 테이블 Hash table

* (Key, Value)로 데이터를 저장하여 빠르게 데이터를 검색할 수 있는 자료구조다.
  * 내부적으로 배열(버킷)을 사용하여 데이터를 저장한다.
  * 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색한다.
  * 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 한다.
* 평균 시간복잡도는 `O(1)`이다.

### 용어

* 해시 테이블은 키(Key), 해시함수(Hash Function), 해시(Hash), 값(value), 저장소(Bucket, Slot)로 이루어져 있다.
* 키(key)는 해시함수(hash function)를 통해 해시(hash)로 변경이 되며 해시는 값(value)과 매칭되어 저장소에 저장이 된다.
* 키(key): 고유한 값이며, 해시 함수의 input이 된다. 다양한 길이의 값이 될 수 있다.
  * 이 상태로 최종 저장소에 저장이 되면 다양한 길이 만큼의 저장소를 구성해 두어야 하기 때문에 해시 함수로 값을 바꾸어 저장이 되어야 공간의 효율성을 추구할 수 있다.
* 해시함수(Hash Function): 키(key)를 해시(hash)로 바꿔주는 역할을 한다.
  * 다양한 길이를 가지고 있는 키(key)를 일정한 길이를 가지는 해시(hash)로 변경하여 저장소를 효율적으로 운영할 수 있도록 도와준다.
  * 서로 다른 키(key)가 같은 해시(hash)가 되는 경우를 해시 충돌(Hash Collision)이라고 하는데, 해시 충돌을 일으키는 확률을 최대한 줄이는 함수를 만드는 것이 중요하다.
* 해시(Hash): 해시 함수(Hash Function)의 결과물이며, 저장소(bucket, slot)에서 값(value)과 매칭되어 저장된다.
* 값(Value): 저장소(bucket, slot)에 최종적으로 저장되는 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능해야 한다.

### 해시 함수

* 해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다.
* 해시 테이블에 사용되는 대표적인 해시 함수
  * Division Method: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다 `주소 = 입력값 % 테이블의 크기`
    * 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.
  * Digit Folding: 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.
  * Multiplication Method: 숫자로 된 Key값 `K`와 0과 1사이의 실수 `A`, 보통 2의 제곱수인 `m`을 사용하여 다음과 같은 계산을 한다. `h(k)=(kAmod1) × m`
  * Univeral Hashing: 다수의 해시함수를 만들어 집합 `H`에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.

### 해시값 충돌 문제 해결 방법

#### 분리 연결법(Separate Chaining)

* 동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것이다.
  * 동일한 버킷으로 접근을 한다면 데이터들을 연결을 해서 관리해준다.
  * 실제로 Java8의 Hash테이블은 Self-Balancing Binary Search Tree 자료구조를 사용해 Chaining 방식을 구현한다.
* 장점: 해시 테이블의 확장이 필요없고 간단하게 구현이 가능하며, 손쉽게 삭제할 수 있다는 장점이 있다.
* 단점: 데이터의 수가 많아지면 동일한 버킷에 chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다.

#### 개방 주소법(Open Addressing)

* 추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다.
* Linear Probing: 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
* Quadratic Probing: 해시의 저장순서 폭을 제곱으로 저장하는 방식이다.
  * 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.
* Double Hashing Probing: 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애는 방식이다.
  * 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.
* Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되기 때문에, 해시 테이블을 재정리 해주는 작업이 필요하다.

### 시간복잡도

* 각각의 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 `O(1)`의 시간복잡도로 데이터를 조회할 수 있다.
* 데이터의 충돌이 발생하면 Chaining에 연결된 리스트들까지 검색을 해야 하므로 `O(N)`까지 시간복잡도가 증가할 수 있다.
  * 충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만, 공간을 많이 사용한다는 치명적인 단점이 있다.
* 테이블이 꽉 차서 테이블을 확장해야 하는 경우, 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확장하지 않도록 테이블을 설계해야 한다.
  * 통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 함
* 해시 테이블에서 자주 사용하는 데이터를 Cache에 적용하여 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

### 해시테이블 자료구조의 단점

* 순서가 있는 배열에는 어울리지 않는다.
  * 상하관계가 있거나, 순서가 중요한 데이터의 경우 Hash Table은 어울리지 않다. 순서와 상관없이 key만을 가지고 hash를 찾아 저장하기 때문이다.
* 공간 효율성이 떨어진다.
  * 데이터가 저장되기 전에 미리 저장공간을 확보해 놓아야 한다. 공간이 부족하거나 아예 채워지지 않은 경우가 생길 가능성이 있다.
* Hash Function의 의존도가 높다.
  * 평균 데이터 처리의 시간복잡도는 O(1)이지만, 이는 해시 함수의 연산을 고려하지 않는 결과이다. 해시함수가 매우 복잡하다면 해시테이블의 모든 연산의 시간 효율성은 증가할 것이다.

----

* 참고: [[자료구조] 해시테이블(HashTable)이란?](https://mangkyu.tistory.com/102) / [Hash, Hashing, Hash Table(해시, 해싱 해시테이블) 자료구조의 이해](https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94hash-table)